import os
import yaml
import re
import html

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
CATALOG_DIR = os.path.join(BASE_DIR, "catalog")
TISTORY_DIR = os.path.join(BASE_DIR, "tistory")

OUT_KO = os.path.join(TISTORY_DIR, "index_ko.html")
OUT_EN = os.path.join(TISTORY_DIR, "index_en.html")

os.makedirs(TISTORY_DIR, exist_ok=True)

HANGUL_RE = re.compile(r"[가-힣]")

def esc(s):
    return html.escape(str(s)) if s is not None else ""

def load_yaml_safe(path: str):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return yaml.safe_load(f)
    except Exception as e:
        print(f"[SKIP] {os.path.basename(path)}")
        print(f"       {e}")
        return None

def normalize_entry(data: dict) -> dict:
    if not isinstance(data, dict):
        return {}
    if "catalog_entry" in data and isinstance(data["catalog_entry"], dict):
        return data["catalog_entry"]
    if "gpt" in data and isinstance(data["gpt"], dict):
        return data["gpt"]
    return data

def guess_lang(entry: dict, filename: str) -> str:
    fn = filename.lower()
    if fn.endswith(("_en.yml", "_en.yaml")) or "_en_" in fn:
        return "en"
    if fn.endswith(("_ko.yml", "_kr.yml", "_kor.yml", "_ko.yaml", "_kr.yaml", "_kor.yaml")) \
       or "_ko_" in fn or "_kr_" in fn or "_kor_" in fn:
        return "ko"

    name = entry.get("name_ko") or entry.get("name") or entry.get("name_en") or ""
    return "ko" if HANGUL_RE.search(str(name)) else "en"

# =========================
# Pass 1: LOAD (IDENTICAL)
# =========================
all_entries = []

for fn in sorted(os.listdir(CATALOG_DIR)):
    if not (fn.lower().endswith(".yml") or fn.lower().endswith(".yaml")):
        continue

    raw = load_yaml_safe(os.path.join(CATALOG_DIR, fn))
    if raw is None:
        continue

    entry = normalize_entry(raw)
    if not entry:
        continue

    entry["_lang"] = guess_lang(entry, fn)
    all_entries.append(entry)

# =========================
# Split (IDENTICAL)
# =========================
ko_entries = [e for e in all_entries if e["_lang"] == "ko"]
en_entries = [e for e in all_entries if e["_lang"] == "en"]

# =========================
# Render (INDEX ONLY)
# =========================
def display_name(e):
    name_en = e.get("name_en") or e.get("name") or ""
    name_ko = e.get("name_ko") or ""
    if name_ko:
        return f"{name_en} · {name_ko}" if name_en else name_ko
    return name_en

def one_line(e, lang):
    return (
        e.get(f"one_line_{lang}")
        or e.get("one_line")
        or e.get("one_line_ko")
        or e.get("one_line_en")
        or ""
    )

def render(title, entries, lang):
    rows = []
    idx = 1
    for e in entries:
        if not e.get("url"):
            continue

        rows.append(f"""
<li style="margin:0 0 14px 0; padding-bottom:10px; border-bottom:1px solid #ddd;">
  <strong>{idx}. {esc(display_name(e))}</strong><br/>
  <span style="color:#555">{esc(one_line(e, lang))}</span><br/>
  <a href="{esc(e['url'])}" target="_blank">GPT 바로가기</a>
</li>
""")
        idx += 1

    return f"""
<div style="font-family:system-ui,-apple-system,Segoe UI,sans-serif">
<h3>{esc(title)}</h3>
<ul style="list-style:none;padding:0;margin:0">
{''.join(rows) if rows else '<li>항목 없음</li>'}
</ul>
</div>
"""

with open(OUT_KO, "w", encoding="utf-8") as f:
    f.write(render("GPT Catalog (KO)", ko_entries, "ko"))

with open(OUT_EN, "w", encoding="utf-8") as f:
    f.write(render("GPT Catalog (EN)", en_entries, "en"))

print("[OK] Tistory KO:", len(ko_entries))
print("[OK] Tistory EN:", len(en_entries))
